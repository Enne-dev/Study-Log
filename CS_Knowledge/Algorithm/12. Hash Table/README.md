### Hash : さまざまな長さのデータを固定された長さの値に変換するアルゴリズム
ex) 

네, 아주 좋은 직감입니다! **"나머지(Modulo)"**가 바로 해시의 핵심이 맞습니다.

무지성 암기가 싫다고 하셨으니, **'도서관 사서의 고충'**이라는 스토리로 해시테이블의 모든 개념을 관통해 드릴게요. 이 스토리만 기억하면 빈칸이 어디에 뚫릴지 보입니다.

---

### 1. 스토리: 까칠한 도서관 사서의 마법 계산기

여러분이 **책 10,000권**이 있는 도서관의 사서라고 상상해 보세요. 책장은 딱 **10개**(`0번` ~ `9번` 책장)밖에 없습니다.

손님이 와서 *"해리포터 찾아주세요"*라고 합니다.
보통이라면 1번 책장부터 10번 책장까지 다 뒤져야겠죠? (이게 배열 탐색, $O(N)$) 너무 느립니다.

그래서 여러분은 **'마법 계산기(해시 함수)'**를 만들었습니다.
책 제목의 글자 수를 세서 **책장 개수(10)**로 나눈 **나머지**를 구하는 계산기입니다.

* **책 제목:** "Harry Potter" (글자 수 12)
* **계산:** $12 \div 10$ 의 나머지 = **2**
* **행동:** 고민도 안 하고 **2번 책장**에 꽂아버립니다.

나중에 손님이 *"해리포터 주세요"* 하면? 똑같이 계산해서 **바로 2번 책장으로 직행**하면 됩니다. 0.1초 만에 찾을 수 있죠. (이게 해시의 속도, $O(1)$)

> **[시험 포인트 1: 해시 함수]**
> * **Hash Function(해시 함수):** 입력(Key)을 숫자(Index)로 바꾸는 함수.
> * **의사코드 빈칸 후보:** 바로 그 **'나머지 연산'** 부분입니다.
> * 코드 형태: `index = key % table_size` (또는 `key mod M`)
> * 

---

### 2. 위기 발생: "충돌(Collision)"

그런데 문제가 터졌습니다.
이번엔 "The Lord of the Rings"(반지의 제왕)가 들어왔습니다. 글자 수가 22자네요.
* **계산:** $22 \div 10$ 의 나머지 = **2**

어라? **2번 책장**엔 이미 해리포터가 있는데요? 자리가 겹쳤습니다.
이걸 있어 보이는 말로 **충돌(Collision)**이라고 합니다. 해시테이블 공부의 90%는 이 '충돌'을 어떻게 해결하느냐입니다.

---

### 3. 해결책 1: 체이닝 (Chaining) - "줄줄이 엮기"

가장 단순한 방법입니다. 2번 책장에 공간이 없으면, 해리포터 책 뒤에 끈으로 묶어서 **매달아(Chain)** 놓는 겁니다.

* 2번 책장: [해리포터] -> [반지의 제왕] -> [또 다른 책] ...

이렇게 **연결 리스트(Linked List)**를 쓰는 방식입니다.

> **[시험 포인트 2: 체이닝 의사코드]**
> * 삽입할 때: 해당 인덱스의 **리스트 맨 앞(Head)**이나 **맨 뒤**에 새 데이터를 붙이는 코드가 나옵니다.
> * 탐색할 때: 해당 인덱스로 가서, 리스트를 따라가며 찾습니다.
> * 

---

### 4. 해결책 2: 개방 주소법 (Open Addressing) - "빈 방 찾기"

끈으로 매달기 지저분해서 싫다면? **"옆 칸으로 가보자"**는 전략입니다.
2번 책장이 찼으면 3번을 보고, 3번도 찼으면 4번을 보는 식이죠. 이걸 **선형 조사법(Linear Probing)**이라고 합니다.

* "해리포터"(나머지 2) -> 2번 칸 점유
* "반지의 제왕"(나머지 2) -> 2번 찼네? -> 3번 칸 점유
* "매트릭스"(나머지 3) -> 3번 찼네? (아까 반지의 제왕이 씀) -> 4번 칸 점유

> **[시험 포인트 3: 선형 조사법의 함정 (Delete)]** **★여기가 시험 킬러 문제★**
>
> 만약 3번 칸에 있던 "반지의 제왕"을 대출(삭제)해 갔다고 칩시다. 3번 칸이 **'텅 빔(NULL)'**이 되겠죠?
>
> 그 다음 손님이 **"매트릭스"(원래 3번 칸 배정, 밀려서 4번에 있음)**를 찾으러 옵니다.
> 사서는 3번 칸으로 갑니다. 어? 비어있네? -> **"매트릭스라는 책은 우리 도서관에 없는데요?"** 라고 오해하고 탐색을 멈춥니다. (4번까지 안 가보고)
>
> 그래서 삭제할 때는 그냥 비우면 안 되고 **"여기 원래 뭐 있었음(DELETED)"**이라는 팻말을 꽂아둬야 합니다. 그래야 사서가 "아, 누가 쓰다 나갔구나, 뒤에 더 있을 수 있겠네?" 하고 4번으로 넘어갑니다.
>
> * **의사코드 빈칸 후보:**
>     * 삽입/탐색 루프: `while (table[i] is occupied)`
>     * 다음 칸 이동: `i = (i + 1) % table_size` (끝에 도달하면 다시 0번으로 돌아가야 하니까 나머지 연산 필수!)
>     * **삭제 조건:** `table[i] = DELETED` (단순 NULL 처리 하면 틀림)
> * 

---

### 5. 시험 직전! 의사코드 빈칸 족집게

시험지 받으면 이 3가지를 먼저 떠올리세요.

1.  **`key % M`**: 무조건 인덱스 구하는 곳에 들어갈 정답.
2.  **`->next`**: 문제에 포인터나 화살표가 보이면 **체이닝** 문제입니다. 리스트 연결하는 곳에 빈칸 뚫립니다.
3.  **`(i + 1) % M`**: 문제에 배열만 보이고 포인터가 없으면 **개방 주소법**입니다. `+1` 하면서 다음 칸 뒤지는 곳에 빈칸 뚫립니다.

이 스토리가 이해되셨나요? 이해되셨으면 바로 다음 단계인 **그래프(BFS/DFS)**로 넘어가서 7일 전사 이어가시죠!
