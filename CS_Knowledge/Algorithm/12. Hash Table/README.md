### Hash : さまざまな長さのデータを固定された長さの値に変換するアルゴリズム
ex) 

1. 스토리: 까칠한 도서관 사서의 마법 계산기여러분이 책 10,000권이 있는 도서관의 사서라고 상상해 보세요. 책장은 딱 10개(0번 ~ 9번 책장)밖에 없습니다.손님이 와서 *"해리포터 찾아주세요"*라고 합니다.보통이라면 1번 책장부터 10번 책장까지 다 뒤져야겠죠? (이게 배열 탐색, $O(N)$) 너무 느립니다.그래서 여러분은 **'마법 계산기(해시 함수)'**를 만들었습니다.책 제목의 글자 수를 세서 **책장 개수(10)**로 나눈 나머지를 구하는 계산기입니다.책 제목: "Harry Potter" (글자 수 12)계산: $12 \div 10$ 의 나머지 = 2행동: 고민도 안 하고 2번 책장에 꽂아버립니다.나중에 손님이 "해리포터 주세요" 하면? 똑같이 계산해서 바로 2번 책장으로 직행하면 됩니다. 0.1초 만에 찾을 수 있죠. (이게 해시의 속도, $O(1)$)[시험 포인트 1: 해시 함수]Hash Function(해시 함수): 입력(Key)을 숫자(Index)로 바꾸는 함수.의사코드 빈칸 후보: 바로 그 '나머지 연산' 부분입니다.코드 형태: index = key % table_size (또는 key mod M)

2. <br>

2. 위기 발생: "충돌(Collision)"그런데 문제가 터졌습니다.이번엔 "The Lord of the Rings"(반지의 제왕)가 들어왔습니다. 글자 수가 22자네요.계산: $22 \div 10$ 의 나머지 = 2어라? 2번 책장엔 이미 해리포터가 있는데요? 자리가 겹쳤습니다.이걸 있어 보이는 말로 **충돌(Collision)**이라고 합니다. 해시테이블 공부의 90%는 이 '충돌'을 어떻게 해결하느냐입니다.
3. <br>
3. 해결책 1: 체이닝 (Chaining) - "줄줄이 엮기"
가장 단순한 방법입니다. 2번 책장에 공간이 없으면, 해리포터 책 뒤에 끈으로 묶어서 매달아(Chain) 놓는 겁니다.

2번 책장: [해리포터] -> [반지의 제왕] -> [또 다른 책] ...

이렇게 **연결 리스트(Linked List)**를 쓰는 방식입니다.

[시험 포인트 2: 체이닝 의사코드]

삽입할 때: 해당 인덱스의 **리스트 맨 앞(Head)**이나 맨 뒤에 새 데이터를 붙이는 코드가 나옵니다.

탐색할 때: 해당 인덱스로 가서, 리스트를 따라가며 찾습니다.
,br>
4. 해결책 2: 개방 주소법 (Open Addressing) - "빈 방 찾기"
끈으로 매달기 지저분해서 싫다면? **"옆 칸으로 가보자"**는 전략입니다. 2번 책장이 찼으면 3번을 보고, 3번도 찼으면 4번을 보는 식이죠. 이걸 **선형 조사법(Linear Probing)**이라고 합니다.

"해리포터"(나머지 2) -> 2번 칸 점유

"반지의 제왕"(나머지 2) -> 2번 찼네? -> 3번 칸 점유

"매트릭스"(나머지 3) -> 3번 찼네? (아까 반지의 제왕이 씀) -> 4번 칸 점유

[시험 포인트 3: 선형 조사법의 함정 (Delete)] ★여기가 시험 킬러 문제★

만약 3번 칸에 있던 "반지의 제왕"을 대출(삭제)해 갔다고 칩시다. 3번 칸이 **'텅 빔(NULL)'**이 되겠죠?

그 다음 손님이 **"매트릭스"(원래 3번 칸 배정, 밀려서 4번에 있음)**를 찾으러 옵니다. 사서는 3번 칸으로 갑니다. 어? 비어있네? -> "매트릭스라는 책은 우리 도서관에 없는데요?" 라고 오해하고 탐색을 멈춥니다. (4번까지 안 가보고)

그래서 삭제할 때는 그냥 비우면 안 되고 **"여기 원래 뭐 있었음(DELETED)"**이라는 팻말을 꽂아둬야 합니다. 그래야 사서가 "아, 누가 쓰다 나갔구나, 뒤에 더 있을 수 있겠네?" 하고 4번으로 넘어갑니다.

의사코드 빈칸 후보:

삽입/탐색 루프: while (table[i] is occupied)

다음 칸 이동: i = (i + 1) % table_size (끝에 도달하면 다시 0번으로 돌아가야 하니까 나머지 연산 필수!)

삭제 조건: table[i] = DELETED (단순 NULL 처리 하면 틀림)
